--
-- Variables
--
mod* VAR principal-sort Var {
  [Var]
}

--
-- Expressions
--
mod! EXP {
  pr(VAR)
  pr(NAT)
  [Var < Exp]
  op n : Nat -> Exp {constr} .
  op _+_ : Exp Exp -> Exp {constr prec: 33 l-assoc} .
  op _-_ : Exp Exp -> Exp {constr prec: 33 l-assoc} .
  op _*_ : Exp Exp -> Exp {constr prec: 31 l-assoc} .
  op _/_ : Exp Exp -> Exp {constr prec: 31 l-assoc} .
  op _%_ : Exp Exp -> Exp {constr prec: 31 l-assoc} .
  op _===_ : Exp Exp -> Exp {constr prec: 40 l-assoc} .
  op _=!=_ : Exp Exp -> Exp {constr prec: 40 l-assoc} .
  op _<_ : Exp Exp -> Exp {constr prec: 40 l-assoc} .
  op _>_ : Exp Exp -> Exp {constr prec: 40 l-assoc} .
  op _&&_ : Exp Exp -> Exp {constr prec: 50 l-assoc} .
  op _||_ : Exp Exp -> Exp {constr prec: 55 l-assoc} .
}

--
-- Statements
--
mod! STM {
  pr(EXP)
  [Stm]
  op estm : -> Stm {constr} .
  op _:=_; : Var Exp -> Stm {constr} .
  op if_{_}else{_} : Exp Stm Stm -> Stm {constr} .
  op while_{_} : Exp Stm -> Stm {constr} .
  op for___{_} : Var Exp Exp Stm -> Stm {constr} .
  op __ : Stm Stm -> Stm {constr prec: 60 id: estm l-assoc} .
}

--
-- Some modules (data stuructures) used in the Minila
-- implementation.
--

mod! BOOL-ERR {
  pr(BOOL)
  [Bool ErrBool < Bool&Err]
  op errBool : -> ErrBool {constr} .
}

mod! NAT-ERR {
  pr(NAT)
  pr(BOOL-ERR)
  [Nat ErrNat < Nat&Err]
  op errNat : -> ErrNat {constr} .
  op p_ : Nat&Err -> Nat&Err .
  op _+_ : Nat&Err Nat&Err -> Nat&Err {assoc comm} .
  op _*_ : Nat&Err Nat&Err -> Nat&Err {assoc comm} .
  op sd : Nat&Err Nat&Err -> Nat&Err .
  op _quo_ : Nat&Err Nat&Err -> Nat&Err .
  op _rem_ : Nat&Err Nat&Err -> Nat&Err .
  op _<_ : Nat&Err Nat&Err -> Bool&Err .
  op _>_ : Nat&Err Nat&Err -> Bool&Err .
  op if_then{_}else{_} : Bool&Err Nat&Err Nat&Err -> Nat&Err .
  --
  var N : Nat .
  vars N&E N&E1 N&E2 : Nat&Err .
  -- p_
  eq p 0 = errNat .
  eq p errNat = errNat .
  -- _+_
  eq errNat + N&E = errNat .
  -- _*_
  eq errNat * N&E = errNat .
  -- sd
  eq sd(errNat,N&E) = errNat .
  eq sd(N&E,errNat) = errNat .
  -- _quo_
  eq N quo 0 = errNat .
  eq errNat quo N&E = errNat .
  eq N&E quo errNat = errNat .
  -- _rem_
  eq N rem 0 = errNat .
  eq errNat rem N&E = errNat .
  eq N&E rem errNat = errNat .
  -- _<_
  eq errNat < N&E = errBool .
  eq N&E < errNat = errBool .
  -- _>_
  eq errNat > N&E = errBool .
  eq N&E > errNat = errBool .
  -- if_then{_}else{_}
  eq if true then {N&E1} else {N&E2} = N&E1 .
  eq if false then {N&E1} else {N&E2} = N&E2 .
}

mod! PAIR (M :: TRIV, N :: TRIV) {
  [Pair]
  op (_,_) : Elt.M Elt.N -> Pair {constr} .
}

mod* TRIV-ERR {
  [Elt Err < Elt&Err]
  op err : -> Err {constr} .
}

mod! LIST (M :: TRIV-ERR) {
  pr(NAT-ERR)
  [List]
  op nil : -> List {constr} .
  op _|_ : Elt.M List -> List {constr} .
  op _@_ : List List -> List {r-assoc} .
  op nth : List Nat&Err -> Elt&Err.M .
  op len : List -> Nat .
  vars X Y : Elt.M .
  vars L L1 : List .
  var N : Nat .
  var NzN : NzNat .
  -- _@_
  eq nil @ L = L .
  eq (X | L1) @ L = X | (L1 @ L) .
  -- nth
  eq nth(L,errNat) = err.M .
  eq nth(nil,N) = err.M .
  eq nth((X | L),0) = X .
  eq nth((X | L),NzN) = nth(L,p NzN) .
  -- len
  eq len(nil) = 0 .
  eq len(X | L) = len(L) + 1 .
}

--
-- Module VAR is declared in ast.cafe.
--
mod! ENTRY {
  pr(PAIR(VAR,NAT) * {sort Pair -> Entry})
  [Entry ErrEntry < Entry&Err]
  op errEntry : -> ErrEntry .
}

view TRIV-ERR2ENTRY from TRIV-ERR to ENTRY {
  sort Elt -> Entry,
  sort Err -> ErrEntry,
  sort Elt&Err -> Entry&Err,
  op err -> errEntry
}

--
-- Variables, together with values (natural numbers) are
-- registered into an environment.
-- An environment is implemented as tables from variables to
-- natural numbers (more concretely as lists of pairs of variables
-- and natural numbers).
--
mod! ENV {
  pr(NAT-ERR)
  pr(LIST(M <= TRIV-ERR2ENTRY)
     * {sort List -> Env, op nil -> empEnv})
  [Env ErrEnv < Env&Err]
  op errEnv : -> ErrEnv {constr} .
  op _|_ : Entry&Err Env&Err -> Env&Err .
  op update : Env&Err Var Nat&Err -> Env&Err .
  op lookup : Env&Err Var -> Nat&Err .
  op if_then{_}else{_} : Bool&Err Env&Err Env&Err -> Env&Err .
  --
  var E : Env .
  vars V V1 : Var .
  vars N N1 : Nat .
  vars E&E E&E1 E&E2 : Env&Err .
  var N&E : Nat&Err .
  var ET&E : Entry&Err .
  -- _|_
  eq errEntry | E&E = errEnv .
  eq ET&E | errEnv = errEnv .
  -- update
  eq update(E&E,V,errNat) = errEnv .
  eq update(errEnv,V,N&E) = errEnv .
  eq update(empEnv,V,N) = (V,N) | empEnv .
  eq update((V1,N1) | E,V,N)
     = if V1 == V then {(V,N) | E} else {(V1,N1) | update(E,V,N)} .
  -- lookup
  eq lookup(errEnv,V) = errNat .
  eq lookup(empEnv,V) = errNat .
  eq lookup((V1,N1) | E,V)
     = if V1 == V then {N1} else {lookup(E,V)} .
  -- if_then{_}else{_}
  eq if true then {E&E1} else {E&E2} = E&E1 .
  eq if false then {E&E1} else {E&E2} = E&E2 .
}

open ENV .
  ops x y : -> Var .
  op env : -> Env .
  eq env = update(update(empEnv,x,0),y,1) .
  red env .
  red errEnv .
  red lookup(env,x) .
  red lookup(env,y) .
  red nth(env,1) .
  red nth(env,2) .
close

--
-- A stack is represented as a list of natural numbers.
--

view TRIV-ERR2NAT-ERR from TRIV-ERR to NAT-ERR {
  sort Elt -> Nat,
  sort Err -> ErrNat,
  sort Elt&Err -> Nat&Err,
  op err -> errNat
}

mod! STACK {
  pr(LIST(M <= TRIV-ERR2NAT-ERR)
     * {sort List -> Stack, op nil -> empstk} )
  [Stack ErrStack < Stack&Err]
  op errStack : -> ErrStack {constr} .
  op _|_ : Nat&Err Stack&Err -> Stack&Err .
  --
  var S&E : Stack&Err .
  var N&E : Nat&Err .
  -- _|_
  eq errNat | S&E = errStack .
  eq N&E | errStack = errStack .
}

--
-- An instruction set
--
mod! INSTRUCT principal-sort Instruct {
  pr(NAT)
  pr(VAR)
  [Instruct ErrInstruct < Instruct&Err]
  op errInstruct : -> ErrInstruct {constr} .
  op push : Nat -> Instruct {constr} .
  op load : Var -> Instruct {constr} .
  op store : Var -> Instruct {constr} .
  op multiply : -> Instruct {constr} .
  op divide : -> Instruct {constr} .
  op mod : -> Instruct {constr} .
  op add : -> Instruct {constr} .
  op minus : -> Instruct {constr} .
  op lessThan : -> Instruct {constr} .
  op greaterThan : -> Instruct {constr} .
  op equal : -> Instruct {constr} .
  op notEqual : -> Instruct {constr} .
  op and : -> Instruct {constr} .
  op or : -> Instruct {constr} .
  op jump : Nat -> Instruct {constr} .
  op bjump : Nat -> Instruct {constr} .
  op jumpOnCond : Nat -> Instruct {constr} .
  op quit : -> Instruct {constr} .
}

view TRIV-ERR2INSTRUCT from TRIV-ERR to INSTRUCT {
  sort Elt -> Instruct,
  sort Err -> ErrInstruct,
  sort Elt&Err -> Instruct&Err,
  op err -> errInstruct
}

--
-- An instruction sequence is represented as a list of instructions.
--
mod! ILIST {
  pr(LIST(M <= TRIV-ERR2INSTRUCT)
     * {sort List -> IList, op nil -> iln} )
}

mod! PNAT1 {
  [PNat]
  op 0 : -> PNat {constr} .
  op s : PNat -> PNat {constr} .
  vars X Y Z : PNat .

  -- sが1回でもかかっている->1以上の自然数
  -- 0と1以上の自然数は常に異なる
  eq (0 = s(Y)) = false .
  eq (s(X) = s(Y)) = (X = Y) .

  -- 
  op _+_ : PNat PNat -> PNat .
  eq 0 + Y = Y .
  eq s(X) + Y = s(X + Y) .

  op _*_ : PNat PNat -> PNat .
  eq 0 * Y = 0 .
  eq s(X) * Y = (X * Y) + Y .

  op fact1 : PNat -> PNat .
  eq fact1(0) = s(0) .
  eq fact1(s(X)) = s(X) * fact1(X) .

  op fact2 : PNat -> PNat .
  op sfact2 : PNat PNat -> PNat .
  eq fact2(X) = sfact2(X,s(0)) .
  eq sfact2(0,Y) = Y .
  eq sfact2(s(X),Y) = sfact2(X,s(X) * Y) .
}

-- 手書きはフォーマットに従う
-- 1. 証明をどこから始めるか書く(proof of theorem)
-- 2. どの変数に着目してどのような方法を使うか
-- 3. 証明に用いるfresh constantを書く(このタイミングでわからないこともあるのでスペースをあける)
-- 4. Base case で証明するものを記載する redexと等式を書く
-- 5. induction caseで証明するもの、帰納法の仮定を書く
-- 6. 証明がどこで終わったのかを書く(end of proof of theorem)

-- -> traceをcafeobjに任せることも可能

-- base case
set trace on
open PNAT1 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 + y) + z = 0 + (y + z) .
close
set trace off

-- indcution case
set trace on
open PNAT1 .
  -- fresh constants
  ops x y z : -> PNat .
  -- IH
  eq (x + Y) + Z = x + (Y + Z) .
  -- check
  red (s(x) + y) + z = s(x) + (y + z) .
close
set trace off

-- commutativityの証明
-- X+Y = Y+X

-- base case
-- 0+y = y+0
-- 0+y->y by(+1)

-- 補題 X + 0 = X (rz+) を仮定
-- y+0->y by(rz+)

-- induction case
-- s(x) + y = y + s(x)
-- x + Y = Y + x -- (IH)
-- s(x) + y -> s(x + y) by(+2)
-- s(x + y) -> s(y + x) by(IH)

-- 補題 X+s(Y) = s(X+Y) (rs+)

-- rz+
-- lemma1
-- X + 0 = X
-- base case
-- 0 + 0 = 0
-- 0 + 0 -> 0 by(+1)

-- induction case
-- x + 0 = x (IH)
-- s(x) + 0 = s(x)
-- s(x) + 0 -> s(x+0) by(+2)
-- s(x+0) -> s(x) by(IH)

-- rs+
-- lemma2
-- s(X) + s(Y) = s(s(X)+Y)

-- base case
-- 0 + s(Y) = s(0+Y)
-- 0 + s(Y) = s(Y) by(+1)

-- s(0+Y) -> s(Y) by(+1)

-- induction case
-- s(x) + s(Y) = s(x+Y) (IH)

-- lemma1
-- base case
open PNAT1 .
  -- check
  red 0 + 0 = 0 .
close

-- induction case
open PNAT1 .
  -- fresh constants
  op x : -> PNat .
  -- IH
  eq x + 0 = x .
  -- check
  red s(x) + 0 = s(x) .
close

-- lemma2
-- base case
open PNAT1 .
  -- fresh constants
  op y : -> PNat .
  -- check
  red 0 + s(y) = s(0 + y) .
close

-- induction case
open PNAT1 .
  -- fresh constants
  ops x y : -> PNat .
  -- IH
  eq x + s(Y) = s(x + Y) .
  -- check
  red s(x) + s(y) = s(s(x) + y) .
close

-- theorem2
-- base case
open PNAT1 .
  -- fresh constants
  op y : -> PNat .
  -- lemmas
  eq X + 0 = X . -- (rz+)
  -- check
  red 0 + y = y + 0 .
close

-- induction case
open PNAT1 .
  -- fresh constants
  ops x y : -> PNat .
  -- lemmas
  eq X + s(Y) = s(X + Y) . -- (rs+)
  -- IH
  eq x + Y = Y + x .
  -- check
  red s(x) + y = y + s(x) .
close

-- assoc of _*_
-- theorem 3
-- (X * Y) * Z = X * (Y * Z)
-- base case
open PNAT1 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 * y) * z = 0 * (y * z) .
close

-- induction case
-- (s(x) * Y) * Z = s(x) * (Y * Z) . 
-- (x * Y) * Z = x * (Y * Z) - (IH)

-- (s(x) * Y) * Z -> ((x * Y) + Y) * Z by(*1)
-- (x * Y) * Z + (Y * Z) この形に持っていければ右辺と等しいことがIHから示せるので分配法則を補題で示す

-- s(x) * (Y * Z) -> (x * (Y * Z)) + (Y * Z)
-- x * (Y * Z) + (Y * Z)

-- lemma1
-- (x + y) * z = (x * z) + (y * z)
-- base case
-- (0 + y) * z = (0 * z) + (y * z)

-- (0 + y) * z -> y * z by(+1)

-- (0 * z) + (y * z) -> 0 + (y * z) by(*1)
-- 0 + (y * z) -> y * z by(+1)

open PNAT1 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 + y) * z = (0 * z) + (y * z) .
close

-- induction case
-- (s(x) + y) * z = (s(x) * z) + (y * z)
-- (x + y) * z = (x * z) + (y * z) -- IH

-- (s(x) + y) * z -> s(x + y) * z by(+)

-- (s(x) * z) + (y * z) -> ((x * z) + z) + (y * z)
-- (x * z) + z + (y * z) -> (x * z) + (y * z) + z by(+)
-- (x * z) + (y * z) + z -> (x + y) * z + z by(IH)
-- s(x + y) * z by(*)

open PNAT1 .
  -- fresh constants
  ops x y z : -> PNat .
  -- IH
  eq (x * Y) * Z = x * (Y * Z) . 
  -- lemma1
close

mod! PNAT2 {
  [PNat]
  op 0 : -> PNat {constr} .
  op s : PNat -> PNat {constr} .
  vars X Y Z : PNat .

  eq (0 = s(Y)) = false .
  eq (s(X) = s(Y)) = (X = Y) .

  -- 
  op _+_ : PNat PNat -> PNat {assoc comm} .
  eq 0 + Y = Y .
  eq s(X) + Y = s(X + Y) .

  op _*_ : PNat PNat -> PNat .
  eq 0 * Y = 0 .
  eq s(X) * Y = (X * Y) + Y .

  op fact1 : PNat -> PNat .
  eq fact1(0) = s(0) .
  eq fact1(s(X)) = s(X) * fact1(X) .

  op fact2 : PNat -> PNat .
  op sfact2 : PNat PNat -> PNat .
  eq fact2(X) = sfact2(X,s(0)) .
  eq sfact2(0,Y) = Y .
  eq sfact2(s(X),Y) = sfact2(X,s(X) * Y) .

}

-- lemma
-- base case
open PNAT2 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 + y) * z = (0 * z) + (y * z) .
close

-- induction case
open PNAT2 .
  -- fresh constants
  ops x y z : -> PNat .
  -- IH
  eq (x + Y) * Z = (x * Z) + (Y * Z) .
  -- check
  red (s(x) + y) * z = (s(x) * z) + (y * z) .
close

-- 分配法則
-- base case
open PNAT2 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 * y) * z = 0 * (y * z) .
close

-- induction case
open PNAT2 .
  -- fresh constants
  ops x y z : -> PNat .
  -- IH
  eq (x + Y) * Z = (x * Z) + (Y * Z) .
  -- check
  red (s(x) + y) * z = (s(x) * z) + (y * z) .
close

-- base case
open PNAT2 .
  -- fresh constants
  ops y z : -> PNat .
  -- check
  red (0 * y) * z = 0 * (y * z) .
close

-- induction case
open PNAT2 .
  -- fresh constants
  ops x y z : -> PNat .
  -- lemmas
  eq (X + Y) * Z = (X * Z) + (Y * Z) . -- (d*o+) -- IH
  eq (x * Y) * Z = x * (Y * Z) .
  -- check
  red (s(x) * y) * z = s(x) * (y * z) .
close

-- theorem4 comm *
-- X * Y = Y * X

-- lemma1
-- theorem y * 0 = 0
-- base case
open PNAT2 .
  -- check
  red 0 * 0 = 0 .
close

-- induction case
open PNAT2 .
  -- fresh constant
  ops x : -> PNat .
  -- IH 
  eq x * 0 = 0 .
  -- check
  red s(x) * 0 = 0 .
close

-- lemma2
-- theorem X * s(Y) = (X*Y) + X

-- base case
-- 0 * s(Y) = (0 * Y) + 0
open PNAT2 .
  -- fresh constant
  ops x y : -> PNat .
  -- check
  red 0 * s(y) = (0 * y) + 0 .
close

-- induction case
open PNAT2 .
  -- fresh constant
  ops x y : -> PNat .
  -- IH
  eq x + s(Y) = (x * Y) + x .
  -- check
  red s(x) * s(Y) = (s(x) * Y) + s(x) .
close


-- theorem comm *
-- base case
open PNAT2 .
  -- fresh constant
  ops x : -> PNat .
  -- IH
  eq x * 0 = 0 * x . -- (rz)
  -- check
  red 0 * s(x) = s(x) * 0 .
close

-- induction case
open PNAT2 .
  -- fresh constants
  ops x y : -> PNat .
  -- lemmas
  eq X * s(Y) = (X * Y) + X . -- (rs) 
  -- IH
  eq x * Y = Y * x .
  -- check
  red s(x) * y = y * s(x) .
close

mod! PNAT3 {
  [PNat]
  op 0 : -> PNat {constr} .
  op s : PNat -> PNat {constr} .
  vars X Y Z : PNat .

  eq (0 = s(Y)) = false .
  eq (s(X) = s(Y)) = (X = Y) .

  -- 
  op _+_ : PNat PNat -> PNat {assoc comm} .
  eq 0 + Y = Y .
  eq s(X) + Y = s(X + Y) .

  op _*_ : PNat PNat -> PNat {assoc comm} .
  eq 0 * Y = 0 .
  eq s(X) * Y = (X * Y) + Y .

  op fact1 : PNat -> PNat .
  eq fact1(0) = s(0) .
  eq fact1(s(X)) = s(X) * fact1(X) .

  op fact2 : PNat -> PNat .
  op sfact2 : PNat PNat -> PNat .
  eq fact2(X) = sfact2(X,s(0)) .
  eq sfact2(0,Y) = Y .
  eq sfact2(s(X),Y) = sfact2(X,s(X) * Y) .

}

-- fact
-- theorem fact1(X) = fact2(X)

-- base case
open PNAT3 .
  -- fresh constants
  ops x : -> PNat .
  -- check
  red fact1(0) = fact2(0) .
close

-- lemma1
-- base case
open PNAT3 .
  -- fresh constants
  ops y z : -> PNat . -- check
  red y * sfact2(0,z) = sfact2(0,y * z) . 
close

-- induction case
open PNAT3 .
  -- fresh constants
  ops x y z : -> PNat .
  -- lemmas eq(X+Y)*Z=(X*Z)+(Y*Z). --(d*o+) -- IH
  eq Y * sfact2(x,Z) = sfact2(x,Y * Z) .
  -- check
  red y * sfact2(s(x),z) = sfact2(s(x),y * z) .
close

-- induction case
-- fact1(s(x)) = fact2(s(x))

-- fact1(X) = fact2(X) IH

-- fact1(s(x)) -> s(x) * fact1(x)

-- fact2(s(x)) -> sfact2(s(x),s(0)) by(sfact1)
-- sfact2(s(x),s(0)) -> sfact2(x,s(x) * s(0)) by(sfact2)
-- sfact2(x,s(x) * s(0)) -> 
open PNAT3 .
  -- fresh constants
  op x : -> PNat .
  -- lemmas
  eq Y * sfact2(X,Z) = sfact2(X,Y * Z) . -- (sf2-p) -- IH
  eq fact1(x) = fact2(x) .
  -- check
  red fact1(s(x)) = fact2(s(x)) .
close