-- Elt,Errを包含するElt&Errを定義,
mod* TRIV-ERR {
  [Elt Err < Elt&Err]
  op err : -> Err .
}

mod! NAT-ERR principal-sort Nat {
  pr(NAT)
  [Nat ErrNat < Nat&Err]
  op errNat : -> ErrNat {constr} .
  op _*_ : Nat&Err Nat&Err -> Nat&Err .
  op if_then{_}else{_} : Bool Nat&Err Nat&Err -> Nat&Err .
  vars NE NE1 NE2 : Nat&Err .
  eq errNat * NE = errNat .
  eq NE * errNat = errNat .
  eq if true then {NE1} else {NE2} = NE1 .
  eq if false then {NE1} else {NE2} = NE2 .
}

-- err時のListの挙動を定義する
mod! GLIST-ERR(E :: TRIV-ERR) {
  [Nil NnList < List]
  [List ErrList < List&Err]
  op errList : -> ErrList {constr} .
  op nil : -> Nil {constr}
  op _|_ : Elt.E List -> List {constr} .  -- push_top
  op _|_ : Elt&Err.E List&Err -> List&Err .
  op hd : Nil -> Err.E .
  op hd : NnList -> Elt.E .
  op hd : ErrList -> Err.E .
  op hd : List&Err -> Elt&Err .
  op tl : Nil -> ErrList .
  op tl : NnList -> List .
  op tl : ErrList -> ErrList .
  op tl : List&Err -> List&Err .
  op _@_ : List List -> List .
  op _@_ : ErrList List&Err -> ErrList .
  op _@_ : List&Err ErrList -> ErrList .
  op _@_ : List&Err List&Err -> List&Err .
  op if_then{_}else{_} : Bool List&Err List&Err -> List&Err .
  var X : Elt.E .
  var XE : Elt&Err.E .
  vars L L2 : List .
  vars LE LE2 : List&Err .
  eq err.E | LE = errList .
  eq XE | errList = errList .
  eq hd(nil) = err.E .
  eq hd(X | L) = X .
  eq hd(errList) = err.E .
  eq tl(nil) = errList .
  eq tl(X | L) = L .
  eq tl(errList) = errList .
  eq nil @ L2 = L2 .
  eq (X | L) @ L2 = X | (L @ L2) .
  eq errList @ LE = errList .
  eq LE @ errList = errList .
  eq if true then {LE} else {LE2} = LE .
  eq if false then {LE} else {LE2} = LE2 .
}

mod! MULTISET(E :: TRIV) {
  [Elt.E < MSet]
  op emp : -> MSet {constr} .
  op _ _ : MSet MSet -> MSet {constr assoc comm id: emp} .
  op if_then{_}else{_} : Bool MSet MSet -> MSet .
  vars MS1 MS2 : MSet .
  eq if true then {MS1} else {MS2} = MS1 .
  eq if false then {MS1} else {MS2} = MS2 .
}

open MULTISET(NAT) .
  red (1 2) 3 == 1 (2 3) .
  red 1 2 == 2 1 .
  red 1 1 1 2 2 == 1 2 1 1 2 .
  red emp 1 emp 2 emp 1 emp 1 emp 2 emp .
  red emp .
  red emp emp .
close

mod! QID-NAT-PAIR principal-sort QNPair {
  pr(QID)
  pr(NAT)
  [QNPair]
  op (_,_) : Qid Nat -> QNPair {constr} .
}

mod! TEST {
  pr(MULTISET(QID-NAT-PAIR))
  op update : MSet Qid Nat -> MSet .
  vars I J : Qid .
  vars N N2 : Nat .
  var MS : MSet .
  eq update(emp,J,N2) = emp .
  eq update((I,N) MS,J,N2) = if I == J then {(I,N2) MS} else {(I,N) update(MS,J,N2)} .
}

open TEST .
  red update(('a,1) ('b,2) ('c,3),'a,99) .
  red update(('a,3) ('b,2) ('c,1),'a,99) .
close

mod! BOOL-IF {
  op if_then{_}else{_} : Bool Bool Bool -> Bool .
  vars B1 B2 : Bool .
  eq if true then {B1} else {B2} = B1 .
  eq if false then {B1} else {B2} = B2 .
}

mod! NAT-IF {
  pr(NAT)
  op if_then{_}else{_} : Bool Nat Nat -> Nat .
  vars N1 N2 : Nat .
  eq if true then {N1} else {N2} = N1 .
  eq if false then {N1} else {N2} = N2 .
} 

mod! TEST2 {
  pr(BOOL-IF)
  pr(NAT-IF)
  pr(MULTISET(QID-NAT-PAIR))
  vars I J : Qid .
  vars N N2 : Nat .
  var MS : MSet .
  op # : MSet Qid -> Nat .
  eq #(emp,J) = 0 .
  eq #((I,N) MS,J) = if I == J then {1 + #(MS,J)} else {#(MS,J)} .

  op isValid : MSet -> Bool .
  eq isValid(emp) = true .
  eq isValid((I,N) MS) = if #(MS,I) > 0 then {false} else {isValid(MS)} .

  op update : MSet Qid Nat -> MSet .
  ceq update((I,N) MS,I,N2) = (I,N2) MS if isValidd((I,N) MS) .
  ceq update(MS,J,N2) = MS if (not isValid(MS)) or #(MS,J) == 0 .
}

open TEST2 .
  red update(('a,1) ('b,2) ('a,3),'a,99) .
  red update(('a,3) ('b,2) ('a,1),'a,99) .
  red update(('a,1) ('b,2) ('c,3),'a,99) .
  red update(('c,3) ('b,2) ('a,1),'a,99) .
  red update(('a,1) ('b,2) ('c,3),'d,99) .
close