mod! NAT-ERR {
  pr(NAT)
  [Nat ErrNat < Nat&Err]
  op errNat : -> ErrNat {constr} .
  op p_ : Zero -> ErrNat . -- minus
  op p_ : ErrNat -> ErrNat .
  op p_ : Nat&Err -> Nat&Err .
  op _quo_ : Nat&Err Zero -> ErrNat . -- divide zero
  op _quo_ : Nat&Err ErrNat -> ErrNat .
  op _quo_ : ErrNat Nat&Err -> ErrNat .
  op _quo_ : Nat&Err Nat&Err -> Nat&Err .
  var NE : Nat&Err .
  eq p 0 = errNat .
  eq p errNat = errNat .
  eq NE quo 0 = errNat .
  eq NE quo errNat = errNat .
  eq errNat quo NE = errNat .
}

mod! NATLIST {
  pr(NAT-ERR)
  [Nil NnNatList < NatList]
  var X : Nat .
  var Y : Nat .
  var Z : Nat .
  var L : NatList .
  var L2 : NatList .
  op nil : -> Nil {constr} .
  op _|_ : Nat NatList -> NnNatList {constr} .  -- push_top
  op hd : Nil -> ErrNat . -- head
  op hd : NnNatList -> Nat .
  op hd : NatList -> Nat&Err .
  op tl : NatList -> NatList . -- tail
  op _@_ : NatList NatList -> NatList . -- append
  op [_.._] : Nat Nat -> NatList . -- range
  op if_then {_} else {_} : Bool NatList NatList -> NatList .

  eq hd(nil) = errNat .
  eq hd(X | L) = X .
  eq tl(nil) = nil .
  eq tl(X | L) = L .
  eq [@1] : nil @ L2 = L2 .
  eq [@2] : (X | L) @ L2 = X | (L @ L2) .
  eq [X .. Y] = if X > Y then {nil} else {X | [X + 1 .. Y]} .
  eq [if1] : if true then {L} else {L2} = L .
  eq [if2] : if false then {L} else {L2} = L2 .
}

-- TRIV->module
-- moduleのパラメータはmodule
-- mod* TRIV { [Elt] }
-- Elt.E は module Eのsort Eltを意味する
mod! GLIST1(E :: TRIV) {
  [Nil NnList < List]
  op nil : -> Nil {constr} .
  op _|_ : Elt.E List -> NnList {constr} .  -- push_top
  op _@_ : List List -> List . -- append
  var X : Elt.E .
  vars L L2 : List .
  eq nil @ L2 = L2 .
  eq (X | L) @ L2 = X | (L @ L2) .
}

-- parameter付きmoduleに具体的な型を適用する
-- module TRIVのEltにmodule NATのNatを割り当てる
view TRIV2NAT from TRIV to NAT {
  sort Elt -> Nat,
}

-- EltをNatに置き換えたものをimportする
mod! NATLIST1 { pr(GLIST1(E <= TRIV2NAT)) }

-- 名付けをしないviewの利用
-- 再利用する必要がない,1回きりのときは以下のように利用する
mod! NATLIST2 {
  pr(GLIST1(E <= view from TRIV to NAT
    { sort Elt -> Nat, }
  ))
}

-- 類推可能な場合はviewを書く必要がない
-- 実parameterのmoduleにprincipal sortが宣言されている場合 Eltをprincipal sortで置き換える
-- E <= view from TRIV to NAT { sort Elt -> Nat, } と同等
mod! NATLIST3 { pr(GLIST1(NAT)) }

-- Elt,Errを包含するElt&Errを定義,
mod* TRIV-ERR {
  [Elt Err < Elt&Err]
  op err : -> Err .
}

mod! GLIST2(E :: TRIV-ERR) {
  [Nil NnList < List]
  op nil : -> Nil {constr} .
  op _|_ : Elt.E List -> NnList {constr} .  -- push_top
  op hd : Nil -> Err.E .
  op hd : NnList -> Elt.E .
  op hd : List -> Elt&Err.E .
  op tl : List -> List .
  op _@_ : List List -> List . -- append
  var X : Elt.E .
  vars L L2 : List .
  eq hd(nil) = err.E .
  eq hd(X | L) = X .
  eq tl(nil) = nil .
  eq tl(X | L) = L .
  eq nil @ L2 = L2 .
  eq (X | L) @ L2 = X | (L @ L2) .
}

-- TRIV-ERRをNAT-ERRで具現化
view TRIV-ERR2NAT-ERR from TRIV-ERR to NAT-ERR {
  sort Elt -> Nat,
  sort Err -> ErrNat,
  sort Elt&Err -> Nat&Err,
  op err -> errNat,
}

-- GLIST2で定義したsort,operatorに別名をつける
mod! NATLIST7 {
  pr(GLIST2(E <= TRIV-ERR2NAT-ERR)
    * {
      sort List -> NatList,
      sort Nil -> NLNil,
      sort NnList -> NnNatList,
      op nil -> nlnil
    }
  )
}

open NATLIST7 .
  red hd(nlnil) .
  red hd((4 | 3 | nlnil) @ (2 | 1 | 0 | nlnil)) .
  red tl(nlnil) .
  red tl((4 | 3 | nlnil) @ (2 | 1 | 0 | nlnil)) .
close

-- err時のListの挙動を定義する
mod! GLIST-ERR(E :: TRIV-ERR) {
  [Nil NnList < List]
  [List ErrList < List&Err]
  op nil : -> Nil {constr}
  op _|_ : Elt.E List -> List {constr} .  -- push_top
  op errList : -> ErrList {constr} .
  op _|_ : Elt&Err.E List&Err -> List&Err .
  op hd : Nil -> Err.E .
  op hd : NnList -> Elt.E .
  op hd : ErrList -> Err.E .
  op hd : List&Err -> Elt&Err .
  op tl : Nil -> ErrList .
  op tl : NnList -> List .
  op tl : ErrList -> ErrList .
  op tl : List&Err -> List&Err .
  op _@_ : List List -> List .
  op _@_ : ErrList List&Err -> ErrList .
  op _@_ : List&Err ErrList -> ErrList .
  op _@_ : List&Err List&Err -> List&Err .
  op if_then{_}else{_} : Bool List&Err List&Err -> List&Err .
  var X : Elt.E .
  var XE : Elt&Err.E .
  vars L L2 : List .
  vars LE LE2 : List&Err .
  eq err.E | LE = errList .
  eq XE | errList = errList .
  eq hd(nil) = err.E .
  eq hd(X | L) = X .
  eq hd(errList) = err.E .
  eq tl(nil) = errList .
  eq tl(X | L) = L .
  eq tl(errList) = errList .
  eq nil @ L2 = L2 .
  eq (X | L) @ L2 = X | (L @ L2) .
  eq errList @ LE = errList .
  eq LE @ errList = errList .
  eq if true then {LE} else {LE2} = LE .
  eq if false then {LE} else {LE2} = LE2 .
}


-- GLIST-ERRをTRIV-ERR2NAT-ERRで具体化
-- Eは自然数を要素に持つLIST
-- GLIST-ERRのsort,operatorをリネーム
mod! NATLIST8 {
  pr(GLIST-ERR(E <= TRIV-ERR2NAT-ERR)
    * {
      sort List -> NatList,
      sort Nil -> NLNil,
      sort NnList -> NnNatList,
      sort ErrList -> ErrNatList,
      sort List&Err -> NatList&Err,
      op nil -> nlnil,
      op errList -> errNatList
    }
  )
}

view TRIV-ERR2NATLIST8 from TRIV-ERR to NATLIST8 {
  sort Elt -> NatList,
  sort Err -> ErrNatList,
  sort Elt&Err -> NatList&Err,
  op err -> errNatList,
}

-- GLIST-ERRをTRIV-ERR2NATLIST8で具現化
-- Eは自然数を要素に持つLISTのLIST
mod! NATLISTLIST1 {
  pr(GLIST-ERR(E <= TRIV-ERR2NATLIST8)
    * {
      sort List -> NatListList,
      sort Nil -> NLLNil,
      sort NnList -> NnNatListList,
      sort ErrList -> ErrNatListList,
      sort List&Err -> NatListList&Err,
      op nil -> nllnil,
      op errList -> errNatListList
    }
  )
}

mod* TRIV-ERR-ORD {
  [Elt Err < Elt&Err]
  op err : -> Err .
  op ord : Elt Elt -> Bool .
}

-- GLIST-ERRをTRIV-ERR-ORDで具現化
mod! GQSORT(E :: TRIV-ERR-ORD) {
  pr(GLIST-ERR(E))
  op qsort : List -> List .
  op partition : Elt.E List List List -> List .
  vars X Y : Elt.E .
  vars L LL RL : List .
  eq qsort(nil) = nil .
  eq qsort(X | nil) = X | nil .
  eq qsort(X | Y | L) = partition(X,Y | L,nil, nil) .
  eq partition(X,nil,LL,RL) = qsort(LL) @ (X | qsort(RL)) .
  eq partition(X,Y | L,LL,RL) = if ord.E(Y,X) then {partition(X,L,Y | LL, RL)} else {partition(X,L,LL,Y | RL)} .
}

-- TRIV-ERR-ORDとNAT-ERRを対応させるview
-- TRIV-ERR-ORDにてordはElt Elt -> Boolなので < はNat Nat -> Boolとなる
view TRIV-ERR-ORD2NAT-ERR from TRIV-ERR-ORD to NAT-ERR {
  sort Elt -> Nat,
  sort Err -> ErrNat,
  sort Elt&Err -> Nat&Err,
  op err -> errNat,
  op ord -> _<_,
}

-- module STRINGを利用
mod! STRING-ERR {
  pr(STRING)
  [String ErrString < String&Err]
  op errStr : -> ErrString {constr} .
}

-- TRIV-ERR-ORDとSTRING-ERRを対応させるview
-- ordをstring<という辞書式順序比較の定義済みのoperatorに対応付ける
view TRIV-ERR-ORD2STRING-ERR from TRIV-ERR-ORD to STRING-ERR {
  sort Elt -> String,
  sort Err -> ErrString,
  sort Elt&Err -> String&Err,
  op err -> errStr,
  op ord -> string<,
}

-- LIST間の順序を比較するためにordを拡張する
-- Elt.E Elt.Eの比較についてはTRIV-ERR-ORDで定義済み
-- ordの実体はviewで具現化される NAT -> _<_, STRING -> string<
-- LISTの場合はord(X | L, Y | L2)で先頭要素同士の比較から初めて再帰的にそれ以降の要素を比較する
mod! GLIST-ERR-ORD(E :: TRIV-ERR-ORD) {
  [Nil NnList < List]
  [List ErrList < List&Err]
  op ord : List List -> Bool . 
  op nil : -> Nil {constr}
  op _|_ : Elt.E List -> List {constr} .  -- push_top
  op errList : -> ErrList {constr} .
  op _|_ : Elt&Err.E List&Err -> List&Err .
  op hd : Nil -> Err.E .
  op hd : NnList -> Elt.E .
  op hd : ErrList -> Err.E .
  op hd : List&Err -> Elt&Err .
  op tl : Nil -> ErrList .
  op tl : NnList -> List .
  op tl : ErrList -> ErrList .
  op tl : List&Err -> List&Err .
  op _@_ : List List -> List .
  op _@_ : ErrList List&Err -> ErrList .
  op _@_ : List&Err ErrList -> ErrList .
  op _@_ : List&Err List&Err -> List&Err .
  op if_then{_}else{_} : Bool List&Err List&Err -> List&Err .
  vars X Y : Elt.E .
  var XE : Elt&Err.E .
  vars L L2 : List .
  vars LE LE2 : List&Err .
  eq err.E | LE = errList .
  eq XE | errList = errList .
  eq hd(nil) = err.E .
  eq hd(X | L) = X .
  eq hd(errList) = err.E .
  eq tl(nil) = errList .
  eq tl(X | L) = L .
  eq tl(errList) = errList .
  eq nil @ L2 = L2 .
  eq (X | L) @ L2 = X | (L @ L2) .
  eq errList @ LE = errList .
  eq LE @ errList = errList .
  eq if true then {LE} else {LE2} = LE .
  eq if false then {LE} else {LE2} = LE2 .
  eq ord(nil,nil) = false .
  eq ord(nil, Y | L2) = true .
  eq ord(X | L,nil) = false .
  eq ord(X | L, Y | L2) = ord.E(X,Y) or ((not ord.E(Y,X)) and ord(L,L2)) .
}

-- 自然数のLISTを比較できるmoduleを定義
mod! NATLIST9 {
  pr(GLIST-ERR-ORD(E <= TRIV-ERR-ORD2NAT-ERR)
  * {
    sort List -> NatList,
    sort Nil -> NLNil,
    sort ErrList -> ErrNatList,
    sort List&Err -> NatList&Err,
    op nil -> nlnil,
    op errList -> errNatList
  })
}

-- 上記moduleとTRIV-ERR-ORDの対応付け
view TRIV-ERR-ORD2NATLIST9 from TRIV-ERR-ORD to NATLIST9 {
  sort Elt -> NatList,
  sort Err -> ErrNatList,
  sort Elt&Err -> NatList&Err,
  op err -> errNatList,
  op ord -> ord,
}

-- GLIST-ERR-ORDをSTRING-ERRで具現化した文字列LISTの定義
mod! STRLIST1 {
  pr(GLIST-ERR-ORD(E <= TRIV-ERR-ORD2STRING-ERR)
    * {
      sort List -> StrList,
      sort Nil -> SLNil,
      sort NnList -> NnStrList,
      sort ErrList -> ErrStrList,
      sort List&Err -> StrList&Err,
      op nil -> slnil,
      op errList -> errStrList,
    }
  )
}

-- 上記STRLISTとTRIV-ERR-ORDの対応付け
-- op ord -> ord, 右辺STRLIST1のordは左辺TRIV-ERR-ORDを具現化したもの
view TRIV-ERR-ORD2STRLIST1 from TRIV-ERR-ORD to STRLIST1 {
  sort Elt -> StrList,
  sort Err -> ErrStrList,
  sort Elt&Err -> StrList&Err,
  op err -> errStrList,
  op ord -> ord, 
}

-- 3 merge sort
mod! MSORT {
  pr(NATLIST)
  op msort : NatList -> NatList .
  op split : NatList NatList NatList -> NatList .
  op merge : NatList NatList -> NatList .
  vars X Y : Nat .
  vars L LL RL : NatList .
  eq msort(nil) = nil .
  eq msort(X | nil) = X | nil .
  eq msort(X | Y | L) = split(L, X | nil, Y | nil) .
  eq split(nil, LL, RL) = merge(msort(LL),msort(RL)) .
  eq split(X | nil,LL,RL) = split(nil,X | LL,RL) .
  eq split(X | Y | L,LL,RL) = split(L,X | LL,Y | RL) .
  eq merge(nil,RL) = RL .
  eq merge(X | LL,nil) = X | LL .
  eq merge(X | LL,Y | RL) = if X > Y then {merge(LL,Y | merge(X | nil,RL))} else {merge(X | merge(Y | nil,LL),RL)} .
}

mod! GMSORT(E :: TRIV-ERR-ORD) {
  pr(GLIST-ERR(E))
  op msort : List -> List .
  op split : List List List -> List .
  op merge : List List -> List .

  vars X Y : Elt.E .
  vars L LL RL : List .

  eq msort(nil) = nil .
  eq msort(X | nil) = X | nil .
  eq msort(X | Y | L) = split(L, X | nil, Y | nil) .
  eq split(nil, LL, RL) = merge(msort(LL),msort(RL)) .
  eq split(X | nil,LL,RL) = split(nil,X | LL,RL) .
  eq split(X | Y | L,LL,RL) = split(L,X | LL,Y | RL) .
  eq merge(nil,RL) = RL .
  eq merge(X | LL,nil) = X | LL .
  eq merge(X | LL,Y | RL) = if ord.E(Y,X) then {Y | merge(X | LL, RL)} else {X | merge(Y | RL, LL)} .
}


-- first->FE, second->SEの組のparametarized module
mod! PAIR(FE :: TRIV, SE :: TRIV) {
  [Pair]
  op (_,_) : Elt.FE Elt.SE -> Pair {constr} .
}

-- if module
mod* TRIV-ERR-IF {
  [Elt Err < Elt&Err]
  op err : -> Err .
  op if_then{_}else{_} : Bool Elt&Err Elt&Err -> Elt&Err .
}

-- TRIV,TRIV-ERR-IFをパラメータに持つmodule
-- PAIRをTRIV,TRIV-ERR-IFで具体化してimportする
-- PAIRで定義しているsort PairをEntryにrenameする
mod! ENTRY(K :: TRIV, V :: TRIV-ERR-IF) {
  pr(PAIR(K,V) * {sort Pair -> Entry})
  [Entry ErrEntry < Entry&Err]
  op errEntry : -> ErrEntry {constr} .
  op (_,_) : Elt.K Elt&Err.V -> Entry&Err .
  var K : Elt.K .
  eq (K,err.V) = errEntry .
}

-- errを定義したmodule
mod! BOOL-ERR {
  [Bool ErrBool < Bool&Err]
  op errBool : -> ErrBool {constr} .
  op if_then{_}else{_} : Bool Bool Bool -> Bool .
  vars B1 B2 : Bool .
  eq if true then {B1} else {B2} = B1 .
  eq if false then {B1} else {B2} = B2 .
}

-- BOOL-ERRをimportする
-- GLIST-ERRをENTRYで具体化する，EltにEntry,ErrにErrEntry,Elt&ErrにEntry&Err,errにerrEntryを割り当てる
-- またList,Nil,NnList,ErrList,List&Errをrenameする
mod! TABLE {
  pr(BOOL-ERR)
  pr(GLIST-ERR(E <= view from TRIV-ERR to ENTRY {
    sort Elt -> Entry,
    sort Err -> ErrEntry,
    sort Elt&Err -> Entry&Err,
    op err -> errEntry
    })
    * {
      sort List -> Table,
      sort Nil -> EmpTable,
      sort NnList -> NeTable,
      sort ErrList -> ErrTable,
      sort List&Err -> Table&Err,
      op errList -> errTable,
      op nil -> empTable
    }
  )
  vars K K2 : Elt.K .
  vars V V2 : Elt.V .
  vars VE VE2 : Elt&Err.V .
  var T : Table .
  var TE : Table&Err .
  op singleton : Elt.K Elt.V -> Table .
  op singleton : Elt.K Elt&Err.V -> Table&Err .
  eq singleton(K,err.V) = errTable .
  eq singleton(K,V) = (K,V) | empTable .
  op isReg : Table Elt.K -> Bool .
  op isReg : Table&Err Elt.K -> Bool&Err .
  eq isReg(errTable,K2) = errBool .
  eq isReg(empTable,K2) = false .
  eq isReg((K,V) | T,K2) = if K == K2 then {true} else {isReg(T,K2)} .
  op lookup : Table Elt.K -> Elt&Err.V .
  op lookup : Table&Err Elt.K -> Elt&Err.V .
  eq lookup(errTable,K2) = err.V .
  eq lookup(empTable,K2) = err.V .
  eq lookup((K,V) | T,K2) = if K == K2 then {V} else {lookup(T,K2)} .
  op update : Table Elt.K Elt.V -> Table .
  op update : Table&Err Elt.K Elt&Err.V -> Table&Err .
  eq update(errTable,K2,VE2) = errTable .
  eq update(TE,K2,err.V) = errTable .
  eq update(empTable,K2,V2) = (K2,V2) | empTable .
  eq update((K,V) | T,K2,V2) = if K == K2 then {(K,V2) | T} else {(K,V) | update(T,K2,V2)} .
  op insert : Table Elt.K Elt.V -> Table&Err .
  op insert : Table&Err Elt.K Elt&Err.V -> Table&Err .
  eq insert(errTable,K2,VE) = errTable .
  eq insert(TE,K2,err.V) = errTable .
  eq insert(T,K2,V2) = if isReg(T,K2) then {errTable} else {(K2,V2) | T} .
  op remove : Table Elt.K -> Table .
  op remove : Table&Err Elt.K -> Table&Err
  eq remove(errTable,K2) = errTable .
  eq remove(empTable,K2) = empTable .
  eq remove((K,V) | T,K2) = if K == K2 then {T} else {(K,V) | remove(T,K2)} .
  op delete : Table Elt.K -> Table&Err .
  op delete : Table&Err Elt.K -> Table&Err .
  eq delete(errTable,K2) = errTable .
  eq delete(T,K2) = if isReg(T,K2) then {remove(T,K2)} else {errTable} .
}

-- ifを定義したstring module
mod! STRING-ERR principal-sort String {
  pr(STRING)
  [String ErrString < String&Err]
  op errStr : -> ErrString {constr} .
  op if_then{_}else{_} : Bool String&Err String&Err -> String&Err .
  vars SE1 SE2 : String&Err .
  eq if true then {SE1} else {SE2} = SE1 .
  eq if false then {SE1} else {SE2} = SE2 .
}

-- EltにQidを割り当てるview
view TRIV2QID from TRIV to QID {
  sort Elt -> Qid
}

-- EltにStringを割り当てるview
view TRIV-ERR-IF2STRING-ERR from TRIV-ERR-IF to STRING-ERR {
  sort Elt -> String,
  sort Err -> ErrString,
  sort Elt&Err -> String&Err,
  op err -> errStr,
  op (if_then{_}else{_}) -> (if_then{_}else{_}),
}

-- keyにQid,valueにStringを持つテーブルの定義
open TABLE(K <= TRIV2QID, V <= TRIV-ERR-IF2STRING-ERR) .
  op t : -> Table .
  eq t = update(update(singleton('java, "java"), 'obj, "OBJ3"), 'c, "C") .
  red t .
  red isReg(t,'obj) .
  red isReg(t,'mk) .
  red lookup(t,'obj) .
  red lookup(t,'mk) .
  red update(t,'mk,"SML#") .
  red update(t,'obj,"CafeOBJ") .
  red insert(t,'mk,"SML#") .
  red insert(t,'obj,"CafeOBJ") .
  red remove(t,'mk) .
  red remove(t,'obj) .
  red delete(t,'mk) .
  red delete(t,'obj) .
close

mod! TAG {
  pr(PAIR(STRING-ERR,NAT-ERR) * {sort Pair -> Tag})
  -- [Tag ErrTag < Tag&Err]
  -- op errTag : -> ErrTag {constr} .
  -- op (_,_) : String&Err Nat&Err -> Tag&Err .
  -- op if_then{_}else{_} : Bool Tag&Err Tag&Err -> Tag&Err .
  -- var SE : String&Err .
  -- var NE : Nat&Err .
  -- vars TE1 TE2 : Tag&Err .
  -- eq (errStr, NE) = errTag .
  -- eq (SE,errNat) = errTag.
  -- eq if true then {TE1} else {TE2} = TE1 .
  -- eq if false then {TE1} else {TE2} = TE2 .
}

